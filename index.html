<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoSim Project</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f8f8f8;
            color: #333;
        }
        header {
            background-color: #333;
            color: #fff;
            padding: 40px;
            text-align: center;
        }
        h1 {
            margin: 0;
            font-size: 36px;
            font-weight: 600;
            letter-spacing: 2px;
        }
        section {
            padding: 40px;
            max-width: 800px;
            margin: 0 auto;
        }
        h2 {
            color: #333;
            font-size: 28px;
            margin-bottom: 20px;
            border-bottom: 2px solid #333;
            padding-bottom: 10px;
        }
        ul {
            list-style-type: none;
            padding: 0;
        }
        ul li {
            margin-bottom: 15px;
        }
        a {
            color: #333;
            text-decoration: none;
            border-bottom: 1px dotted #333;
        }
        a:hover {
            border-bottom: 1px solid #333;
        }
        img {
            max-width: 100%;
            height: auto;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        pre {
            background-color: #f1f1f1;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
        }
        .iframe-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 30vh;
        }

        .iframe-container iframe {
            max-width: 100%;
            max-height: 100%;
        }
    </style>
</head>
<body>
    <header>
        <h1>GeoSim</h1>
    </header>

    <section id="sneak peek">
        <h2> Sneak Peek </h2>
    <div class="iframe-container">
        <iframe src="https://player.vimeo.com/video/945634335?badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479" width="640" height="480" frameborder="0" allow="autoplay; fullscreen; picture-in-picture; clipboard-write" title="Non-euclidean solar system"></iframe>
    </div>
    </section>

    <section id="summary">
        <h2>About</h2>
        <p><strong>Title:</strong> GeoSim</p>
        <p><strong>Summary:</strong> We build a hardware accelerated ray marcher capable of rendering non-euclidian geometries in real time. In the process we developed understanding of ray marching, the mathematics of non-euclidean geometry, the CUDA programming model, and basic hardware-acceleration programming principles.</p>
        <p><strong>Team Members:</strong></p>
        <ul>
            <li>Nico Castaneda (CS 284B)</li>
            <li>Tianyun Yuan (CS 284B + CS 184/284A TA)</li>
            <li>Jonathan Zakharov (CS184 + CS 284B)</li>
        </ul>
    </section>


    <section id="problem">
        <h2>Problem Description</h2>
        <p>We want to visualize non-euclidean geometry with photorealistic accuracy.</p>
    </section>

    <section id="problem">
        <h2>Results</h2>
        <p>

            <br>
            Footage from our interactive demo of hyperbolic raymarcher prototype:
            <br>
            <img src="images/hyp (trimmed).gif" width="80%">
            <br>
            Physically-based, real-time rendering of non-euclidean solar system:
            <br>
            <img src="images/solar_system_naive.gif" width="80%">
            <img src="images/solar_system.gif" width="80%">
            <img src="images/solar_system_2.gif" width="80%">

        </p>
    </section>

    <section id="technical-approach">
        <h2>Technical Approach</h2>
        <p>The project codebase revolves around CUDA. The executable is set up to run on <a href="https://www.csua.berkeley.edu/">CSUA</a> virtual machines, with NVIDIA Tesla V100 compute. We use the nvcc compiler to generate binrary, and CMake to manage dependencies.</p>

        <h3>Libraries Used</h3>
        <p>We use C++ libraries to streamline the process, including:</p>
        <ul>
            <blockquote>
                <li>LodePNG - Serializing framebuffers in memory into .png files</li>
                <li>GLM - Linear algebra and vector mathematics</li>
                <li>SFML - Windowing and input of interactive prototype</li>
            </blockquote>
        </ul>
        <p>Additionally, we used NumPy in our Python scripts to write unit test and numerically verify our mathematical computations and results.</p>

        <h3>CUDA</h3>
        <p>Compute Unified Device Architecture (CUDA) is a parallel computing interface that allows non-serial algorithms to be off-loaded onto GPUs. We found CUDA to be particularly helpful, as the non-euclidian ray-marching algorithm can be executed in parallel: pixel values do not depend on each other.</p>

        <h4>Kernel, Block and Thread</h4>
        <p>When offloading work to GPU, we initialize a CUDA kernel, which is executed by many threads in parallel. The threads are then organized into blocks, within which the threads synchronize and communicate through shared GPU memory. This model allows for massive parallelism. In our implementation, we initialize a fixed size of CUDA blocks, each block containing a fixed size of CUDA threads. Each thread is responsible for the rendering algorithm of one pixel. We index the workers threads in a two-dimensional array, where we intuitively assign pixel coordinates to each thread, and dispatch the rendering work.</p>

    </section>

    <section id="algorithm">
        <h2>The Idea</h2>
        <p>The key idea at hand is simple. Assuming familiarity with raytracing, in which scenes are represented explicitly and ray-geometry intersections can be solved for analytically, ray marching is the implicit and approximate counterpart. Instead of solving an equation to find the intersection of a ray and a primitive like in raytracing, ray marching represents its primitive with signed distance functions (SDFs) which measure the signed distance between a point and the surface of the primitive. By taking the signed distance between our primitive and our ray origin, we can measure how much closer we can move or "march/step" in the direction of the ray before intersecting. We can repeat this routine until one of two conditions is met: we've reached an arbitrarily close distance from our primitive and can approximate the ray's intersection with it, or we have taken an arbitrary number of steps without reaching the previous condition, thus not intersecting any primitive. This is the algorithm of ray marching, abstract and agnostic of any geometries.</p>
        <p>In our classical renderers and day to day lives, we assume the geometric optics model of light which states that light travels along the shortest path: along rays or straight lines. This assumption enables much of raytracing. However, dropping Euclid's fifth postulate:</p>
        <blockquote>
            <p>"if a straight line falling on two straight lines make the interior angles on the same side less than two right angles, the two straight lines, if produced indefinitely, meet on that side on which are the angles less than the two right angles."</p>
        </blockquote>
        <p>We leave the land of euclidean geometry, and can no longer make this assumption. In non-euclidean geometries, the shortest path between two points need not be a straight line. Yet light still does travel along geodesics. This is where we must turn to ray marching as our technique for its ability to march along the geodesic path of light. That is, we use ray marching as described above to march along the geodesic path of light in our non-euclidean space.</p>

        <pre><code>
            ComputeClosestIntersection(Ray r, Scene s)
            {
                Integer MAX_NUM_STEPS = X
                Scalar MIN_HIT_DISTANCE = EPS
            
                Position p = r.origin
                Direction d = r.direction
            
                for i in (1, ... , MAX_NUM_STEPS)
                {
                    Scalar distance = SDF(p, scene)
            
                    // Approximate Intersection
                    if (distance < MIN_HIT_DISTANCE)
                        return ClosestPrimitive(p, scene)
            
                    // Step
                    p = geodesicFlowPosition(p, d, distance)
                    d = geodesicFlowDirection(p, d, distance)
                }
            
                // Ray Miss
                return NIL
            }
        </code></pre>
        </section>            

    <section id="challenges">
        <h2>Challenges</h2>
        <h3>Compute</h3>
        <p>As a team of three, none of us had access to a CUDA-ready GPU. We obtained compute from <a href="https://www.csua.berkeley.edu/">CSUA</a> that has NVIDIA GPUs. We also had a difficult time learning about the C++ compilation tooling on the remote machine. The remote machine has nvcc cuda compiler ready, however, setting up the compilation pipeline using CMake posed the team another challenge. Eventually, we managed to compile a simple cuda program. Directly writing code in cuda on a remote machine does not provide a "visual" feedback. Instead, we decide to prototype our H3 raymarching algorithm in an existing CPU-based custom <a href="https://github.com/pritzza/Rodent-Raytracer">pathtracer</a> written by Jonathan.</p>
        
        <h3>Mathematics of Non-Euclidean Geometry</h3>
        <p>One of the greatest challenges was understanding the underlying mathematics of non euclidean geometry. We began with no exposure to any formal mathematical ideas about noneuclidean geometry. Few people have made 3D visualizations of hyperbolic space and fewer have made accessible resources. We based much of our efforts off the works of Rémi Coulon, Elisabetta A. Matsumoto, Henry Segerman, Steve J. Trettel: <a href="https://arxiv.org/abs/2010.15801">Ray-marching Thurston geometries</a> and <a href="https://arxiv.org/abs/1702.04004"> Non-euclidean virtual reality I: explorations of H3</a>. The former being a mathematically rich but dense 140+ page dissertation on how to visualize all 8 of the Thurston Geometries. The dissertation goes into much mathematical rigor, touching on primarily geometric topology and differential geometry as well as numerical analysis and differential equations. Concepts quite foreign to us took a while to understand and implement correctly. Not having an intuition for the visuals of non euclidean geometry, many unit tests were made to verify the numerical results of all our calculations. Eventually it was all mostly understood: the different models of H3, their numerical representations, numerical stabilities, computational costs, and other pros and cons; we chose the use the hyperboloid model so we needed to know how to represent and verify that a point lie on the hyperboloid, tell if a direction was in the tangent space of a point, how to flow along the geodesics of hyperbolic space, how to represent a scene in hyperbolic space. Understanding these mathematics was crucial to creating and implementing a hyperbolic ray marcher.</p>

        <h3>Hyperbolic Raymarching</h3>
        <p>Conquering the foreign abstract mathematics and then its discrete numerical representation, we needed to adapt our home made euclidean path tracer into an interactive hyperbolic raymarcher. We first began by engineering the euclidean path tracer into a euclidean ray marcher. In a few short hundred lines of code, we succeeded. The next step was to abstract and generalize the capabilities of the ray marcher to be able to march in arbitrary geometries. Through  hundreds of lines of debugging tests, hundreds of lines of dedicated scripts to sanity check numerical results, rereads of the math papers, and banging our heads against the wall, we came to a result which we know to be correct. A challenge with the alienness of non-euclidean geometry is our inability to visualize it. Days were spent realizing the fact that we could not go off visual intuition very much to verify results, hence the need to write many many numerical tests. </p>
        
    </section>

    <section id="lessons">
        <h2>Lessons Learned</h2>
        <h3>Collaboration</h3>
        <p>Collaboration, consultation, and communication is the key to getting things done. Working in a team with some skills in common but many more disjoint proved that as a whole, you’re only as strong as the weakest link of the chain when it comes to communication. It was necessary for us to be as accommodating and empathetic as possible where we didnt excel. Furthermore, having none of us on the team be experts at mathematics let alone non-euclidean geometry, the importance of collaboration was shown to us as mathematical consultation was necessitated. We thank those at the Berkeley Mathematics Undergraduate Student Association for helping our understanding of hyperbolic geometry in this project.</p>

        <h3>Mathematics</h3>
        <p>Mathematical understanding, and more broadly, all understanding cannot be rushed. One can reasonably estimate the times it takes to perform a feat of physical labor. One can also, with less accuracy though, estimate the times it takes to perform a feat of engineering. However one cannot accurately estimate the times it takes to perform a feat of intellectuality. Intellectual deadlines need to be taken with a grain of salt because it is difficult to know when a concept will make sense. Yet in a context such as industry, academia, or this project, where deadlines are final, it only means they need to be treated with a lot more respect and caution. One cannot foresee when a concept will make sense, thus they must be proactive as resources permit.</p>
    </section>

    <section id="results">
        <h2>Results</h2>
        <p>Through the work of our team we successfully achieved a working prototype of a software hyperbolic raymarcher and a hardware accelerated CUDA raymarcher primed for generalization of non euclidean geometries. We were able to show our proof of concept: functioning hyperbolic raymarching. Now our CUDA raymarcher is designed to abstract details of what geometry we’re in, meaning implementing arbitrary (non)-euclidean geometry is as simple a task as just slotting in the right math functions.</p>
        <br>
        (We also got some cool bug art along the way!)
        <br>
        <img src="images/bugart0.png" width="45%">
        <img src="images/bugart1.png" width="45%">
        <img src="images/bugart2.png" width="45%">
        <img src="images/bugart3.png" width="45%">
        <br>
        <br>

        A video of the development of the hyperbolic raymarcher prototype can be seen <a href="https://youtu.be/Il_7HWKKSwU">here</a> and a video of the interactive demo <a href="https://youtu.be/0cmYqJrQKbc">here</a>.

    </section>

    <section id="contributions">
        <h2>Contributions</h2>

        Nico Castaneda: Compute and CUDA ray marcher
        <br>
        Tianyun Yuan: Compute, CUDA ray marcher, DevOps, texture mapping, environment mapping, environment light, scene architecture, TAing CS184
        <br>
        Jonathan Zakharov: Mathematics and hyperbolic prototype
    </section>

    <section id="Extra">
        <h2>Additional Links</h2>

        <blockquote>
            <h3>Development Video</h3>
            <p><a href="https://youtu.be/Il_7HWKKSwU">View Development Video</a></p>

            <h3>Demo Video</h3>
            <p><a href="https://youtu.be/0cmYqJrQKbc">View Demo Video</a></p>

            <h3>Presentation</h3>
            <p><a href="https://docs.google.com/presentation/d/1DGa2JtVpf00P6wfAUAklz1qCobAbrCqFwy42HWV87XU/edit?usp=sharing">View Presentation</a></p>
        </blockquote>
    </section>

</body>
</html>
